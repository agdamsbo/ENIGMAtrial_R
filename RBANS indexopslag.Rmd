---
title: "RBANS index score calculator"
author: "Andreas Gammelgaard Damsbo"
date: "3/15/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readxl)
```

# Importing index tables

## Writing funtion
Function imports tables
```{r}
list_tables<-function(table_paths,sheets=2,include_all=TRUE){
  # Sheets denotes the number of sheets to import. At the moment only the amount can be specified, not a range or specific sheets. Its on the list!
  # This might be shortened inspired by this thread: https://stackoverflow.com/questions/9564489/read-all-files-in-a-folder-and-apply-a-function-to-each-data-frame
  require(readxl)
  
paths<-table_paths
tbls<-list()
table_names<-c()

for(i in 1:length(paths)){
  path<-paths[i]
  table_name<-paste0("index_",unlist(strsplit(rev(unlist(strsplit(paths[i], "[/]")))[1], "[.]"))[1])
  table_names<-c(table_names,table_name)
  index_domain<-list()
  
  if (include_all==TRUE){
    t_shts<-length(excel_sheets(path))
    for(x in 1:t_shts) {
      shts<-1:t_shts
      index_domain[[excel_sheets(path)[x]]] <- data.frame(read_excel(path=path, sheet=shts[x]))
    }
  }
  
  if (include_all==FALSE){
    for(x in 1:sheets) {
      shts<-1:sheets
      index_domain[[excel_sheets(path)[x]]] <- data.frame(read_excel(path=path, sheet=shts[x]))
    }
    }
  tbls<-append(tbls,list(index_domain))
}
names(tbls)<-table_names

return(tbls)

# The read_excel function guesses the data type. If clear definition is needed, this can be added:
      # ,col_types = c("numeric","numeric","text","text","text","text")
      # In R version >4 stringAsfactor is FALSE as default.
      # The "read_excel" also works with both .xls and .xlsx. The first is much faster though!
}
```

## Creating a list of imported lists
```{r}
tbl_folder<-"/Users/andreas/Documents/LÃ¦ge/Forskning/PhD/ENIGMA/RBANS/RBANS_index_tables"
tbl_docs<- list.files(tbl_folder, pattern="*.xlsx", full.names=TRUE)
index_tables<-list_tables(tbl_docs)
```


# Calculating the index scores

## Creating a test dataset

```{r}
var_names=c("a","b","c","d","e")

parts=10

dta<-data.frame(id=1:parts,age=as.numeric(sample(18:110,10)),matrix(sample(20:40,replace=TRUE), ncol = length(var_names), nrow = parts,dimnames=list(NULL,var_names)),version="a")
```

## Formatting scale_total
```{r}
interval_extention<-function(x,coln=1){
  # Function to extend written intervals in cells to "long" format by repeating associated variables.
  # x denotes the dataframe or vector to extend. coln denotes the desired column to extend the dataframe from. Default is 1. Only works with intervals seperated by "-".
  # Use case: extension of index tables, where several raw scores equals to the same indexscore.
  
  if (is.data.frame(x)&length(x)==1){
    stop("Check that input is correctly formatted as vector or that data frame has at least two columns")}
  
  if (!is.data.frame(x)&!is.vector(x)){stop("Check input format. Should be vector or data.frame")}
  
  if (is.data.frame(x)){
  dta<-cbind(x[coln],x[-coln])
  
  df<-data.frame(rbind(1:ncol(dta)))[0,]
  cnms<-colnames(dta)
  colnames(df)<-cnms
  
  for (i in 1:nrow(dta)){
    n<-as.numeric(unlist(strsplit(dta[i,1], "[-]")))
    suppressWarnings(dt<-data.frame(n[1]:n[2],dta[i,2:ncol(dta)]))
    # Unsure why this function results in a warning. Deal with it!
    colnames(dt)<-cnms
    df<-rbind(df,dt)
    }
  return(df)
  }
 
  if (is.vector(x)){
    o<-c()
    for (i in 1:nrow(dta)){
     n<-as.numeric(unlist(strsplit(x[i], "[-]")))
     o<-c(o,n[1]:n[2])
    }
    return(o)
  }
  }

## Example:
# test<-data.frame(int=c("1-3","4-9","10-15"),score=1:3,diff=4:6)
# interval_extention(test)
# interval_extention(test[,1])
```


```{r}
index_tables$index_scale_total$scale_total<-interval_extention(index_tables$index_scale_total$scale_total)
```



## Defining function to calculate index scores

```{r}
index_from_raw<-function(dta,table_list=index_tables,version="version",age="age",raw_columns=c("a","b","c","d","e")){
  table_list=index_tables
  version="version"
  age="age"
  raw_columns=c("a","b","c","d","e")
  
  ## Categorizing age to age interval of index lists
  ndx_nms<-names(table_list)[1:length(table_list)-1]
  
  ## This is the only non-generalised part. Please be inspired and solve it your own way! :)
  ## Intervals are 20-39, 40-49, 50-59, 60-69, 70-79, 80-89.
  index_age<-ifelse(dta[[age]]>=18&dta[[age]]<=39,ndx_nms[1],
                           ifelse(dta[[age]]>=40&dta[[age]]<=49,ndx_nms[2],
                                  ifelse(dta[[age]]>=50&dta[[age]]<=59,ndx_nms[3],
                                         ifelse(dta[[age]]>=60&dta[[age]]<=69,ndx_nms[4],
                                                ifelse(dta[[age]]>=70&dta[[age]]<=79,ndx_nms[5],
                                                       ifelse(dta[[age]]>=80,ndx_nms[6],NA))))))
  
  df<-data.frame(matrix(1:7,ncol=7,nrow = nrow(dta),byrow = T))
cinms<-names(table_list[[1]])
  colnames(df)<-c(cinms,"total_r","total_i")
  dt<-dta
  
for (i in 1:nrow(dta)){
  # i=1
  
  ## Selecting tables based on age
  lst<-table_list[[index_age[i]]]
  
  
  v<-dta[i,version]
  ## test version. Standard colname is set as "version"
  
  # A
  ndx<-c()
    for (s in 1:length(lst)){
      # s=1
      is<-lst[[s]]$indexscore[lst[[s]]$total_rawscore==dt[i,raw_columns[s]]&lst[[s]]$version==v]
      ndx<-c(ndx,is)
      }
 
  # Total
  df[i,1:5]<-ndx
  df$total_r[i]<-sum(df[i,1:5])
  
  ## Total index lookup
  df_scale<-index_tables[[length(index_tables)]][[1]]
  df$total_i[i]<-df_scale[2][df_scale[1]==df$total_r[i]]
}
  return(df)
}
```


## Calculating indexscores
```{r}
index_from_raw(dta)
```













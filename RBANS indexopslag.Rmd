---
title: "RBANS index score calculator"
author: "Andreas Gammelgaard Damsbo"
date: "3/15/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readxl)
```

# Importing index tables

## Writing funtion
Function imports tables
```{r}
list_tables<-function(table_paths,sheets=2,include_all=TRUE){
  # Sheets denotes the number of sheets to import. At the moment only the amount can be specified, not a range or specific sheets. Its on the list!
  # This might be shortened inspired by this thread: https://stackoverflow.com/questions/9564489/read-all-files-in-a-folder-and-apply-a-function-to-each-data-frame
  require(readxl)
  
paths<-table_paths
tbls<-list()
table_names<-c()

for(i in 1:length(paths)){
  path<-paths[i]
  table_name<-paste0("index_",unlist(strsplit(rev(unlist(strsplit(paths[i], "[/]")))[1], "[.]"))[1])
  table_names<-c(table_names,table_name)
  index_domain<-list()
  
  if (include_all==TRUE){
    t_shts<-length(excel_sheets(path))
    for(x in 1:t_shts) {
      shts<-1:t_shts
      index_domain[[excel_sheets(path)[x]]] <- data.frame(read_excel(path=path, sheet=shts[x]))
    }
  }
  
  if (include_all==FALSE){
    for(x in 1:sheets) {
      shts<-1:sheets
      index_domain[[excel_sheets(path)[x]]] <- data.frame(read_excel(path=path, sheet=shts[x]))
    }
    }
  tbls<-append(tbls,list(index_domain))
}
names(tbls)<-table_names

return(tbls)

# The read_excel function guesses the data type. If clear definition is needed, this can be added:
      # ,col_types = c("numeric","numeric","text","text","text","text")
      # In R version >4 stringAsfactor is FALSE as default.
      # The "read_excel" also works with both .xls and .xlsx. The first is much faster though!
}
```

## Creating a list of imported lists
```{r}
tbl_folder<-"/Users/andreas/Documents/LÃ¦ge/Forskning/PhD/ENIGMA/RBANS/RBANS_index_tables"
tbl_docs<- list.files(tbl_folder, pattern="*.xlsx", full.names=TRUE)
index_tables<-list_tables(tbl_docs)
```


# Calculating the index scores

## Creating a test dataset

```{r}
var_names=c("a","b","c","d","e")

parts=10

dta<-data.frame(id=1:parts,age=as.numeric(sample(18:110,10)),matrix(sample(20:40,replace=TRUE), ncol = length(var_names), nrow = parts,dimnames=list(NULL,var_names)),version="a")
```

## Categorising patients according to index table
```{r}
ndx_nms<-names(index_tables)[1:length(index_tables)-1]
# should be changed to this: names(index_tables)

dta$index_c<-ifelse(dta$age>17&dta$age<40,ndx_nms[1],
                           ifelse(dta$age>39&dta$age<50,ndx_nms[2],
                                  ifelse(dta$age>49&dta$age<60,ndx_nms[3],
                                         ifelse(dta$age>59&dta$age<70,ndx_nms[4],
                                                ifelse(dta$age>69&dta$age<80,ndx_nms[5],
                                                       ifelse(dta$age>79,ndx_nms[6],NA))))))

```

## Formatting scale_total
```{r}
interval_extention<-function(x,coln=1){
  # Function to extend written intervals in cells to "long" format by repeating associated variables.
  # x denotes the dataframe or vector to extend. coln denotes the desired column to extend the dataframe from. Default is 1. Only works with intervals seperated by "-".
  # Use case: extension of index tables, where several raw scores equals to the same indexscore.
  
  if (is.data.frame(x)&length(x)==1){
    stop("Check that input is correctly formatted as vector or that data frame has at least two columns")}
  
  if (!is.data.frame(x)&!is.vector(x)){stop("Check input format. Should be vector or data.frame")}
  
  if (is.data.frame(x)){
  dta<-cbind(x[coln],x[-coln])
  
  df<-data.frame(rbind(1:ncol(dta)))[0,]
  cnms<-colnames(dta)
  colnames(df)<-cnms
  
  for (i in 1:nrow(dta)){
    n<-as.numeric(unlist(strsplit(dta[i,1], "[-]")))
    suppressWarnings(dt<-data.frame(n[1]:n[2],dta[i,2:ncol(dta)]))
    # Unsure why this function results in a warning. Deal with it!
    colnames(dt)<-cnms
    df<-rbind(df,dt)
    }
  return(df)
  }
 
  if (is.vector(x)){
    o<-c()
    for (i in 1:nrow(dta)){
     n<-as.numeric(unlist(strsplit(x[i], "[-]")))
     o<-c(o,n[1]:n[2])
    }
    return(o)
  }
  }

## Example:
# test<-data.frame(int=c("1-3","4-9","10-15"),score=1:3,diff=4:6)
# interval_extention(test)
# interval_extention(test[,1])
```


```{r}
index_tables$index_scale_total$scale_total<-interval_extention(index_tables$index_scale_total$scale_total)
```



## Defining function to calculate index scores

DET VIRKER VIST IKKE HELT!
```{r}
# index_from_raw<-function(dta,table_list){
df<-data.frame(matrix(1:7,ncol=7,nrow = nrow(dta),byrow = T))
  colnames(df)<-c("a_i","b_i","c_i","d_i","e_i","total","total_i")
  # df<-df[0,]
  dt<-dta
  
  clnms<-c("a","b","c","d","e")
for (i in 1:nrow(dta)){
  # i=2
  
  ## Selecting tables based on age
  lst<-index_tables[dt$index_c[i]]
  
  version<-"a"
  ## should be dependent on variable
  
  # A
  ndx<-c()
  for (s in s:length(lst[[1]])){
    is<-lst[[1]][[s]]$indexscore[lst[[1]][[s]]$total_rawscore==dt[i,clnms[s]]&lst[[1]][[s]]$version==version]
    ndx<-c(ndx,is)
  }
 
  # Total
  df[i,1:5]<-ndx
  df$total[i]<-sum(df[i,1:5])
  
  ## Total index lookup
  df_scale<-index_tables[[length(index_tables)]][[1]]
  df$total_i[i]<-df_scale[2][df_scale[1]==df$total[i]]
}
#   return(df)
# }
```












